using MewtocolNet.Events;
using MewtocolNet.RegisterAttributes;
using MewtocolNet.UnderlyingRegisters;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MewtocolNet.Registers {

    public abstract class Register : IRegister, INotifyPropertyChanged {

        /// <summary>
        /// Gets called whenever the value was changed
        /// </summary>
        public event RegisterChangedEventHandler ValueChanged;

        public event PropertyChangedEventHandler PropertyChanged;

        //links to 
        internal MewtocolInterface attachedInterface;

        internal List<RegisterPropTarget> boundProperties = new List<RegisterPropTarget>();

        internal Type underlyingSystemType;
        internal AreaBase underlyingMemory;
        internal bool autoGenerated;
        internal bool isAnonymous;

        internal protected object lastValue = null;
        internal string name;
        internal uint memoryAddress;
        internal int pollLevel = 0;

        internal uint successfulReads = 0;
        internal uint successfulWrites = 0;

        internal int updateCountTimerCycle;
        internal float updateFreqHz;

        internal bool wasOverlapFitted = false;

        private Stopwatch timeSinceLastUpdate;

        private float updateFreqFastCount;
        private float[] updateFreqAvgList;

        /// <inheritdoc/>
        public bool IsAutoGenerated => autoGenerated;

        /// <inheritdoc/>
        internal MewtocolInterface AttachedInterface => attachedInterface;

        /// <inheritdoc/>
        public Type UnderlyingSystemType => underlyingSystemType;

        /// <inheritdoc/>
        public object ValueObj => lastValue;

        /// <inheritdoc/>
        public string ValueStr => GetValueString();

        /// <inheritdoc/>
        public RegisterPrefix RegisterType { get; internal set; }

        /// <inheritdoc/>
        public IMemoryArea MemoryArea => underlyingMemory;

        /// <inheritdoc/>
        public string Name => name;

        /// <inheritdoc/>
        public string PLCAddressName => GetMewName();

        /// <inheritdoc/>
        public uint MemoryAddress => memoryAddress;

        /// <inheritdoc/>
        public int PollLevel {
            get => pollLevel;
            internal set { 
                PollLevel = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(PollLevel)));
            }
        }

        /// <inheritdoc/>
        public float UpdateFreqHz {
            get => updateFreqHz;
            private set {
                updateFreqHz = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(UpdateFreqHz)));
            }
        }

        public string MemoryAreaInfo => underlyingMemory.ToString();

        public string MemoryAreaHash => underlyingMemory.GetHashCode().ToString();

        internal Register() { }

        internal virtual void OnPlcConnected () {

           timeSinceLastUpdate = Stopwatch.StartNew();
           updateFreqAvgListIteration = 0;
            updateFreqAvgList = new float[10];


        }

        internal virtual void OnPlcDisconnected () {

            timeSinceLastUpdate?.Stop();
            UpdateFreqHz = default;
            updateFreqAvgList = new float[10];
            updateFreqFastCount = default;

        }

        internal virtual void OnInterfaceCyclicTimerUpdate (int cyclicTimerRateMs) {

            UpdateCountTimerTick(cyclicTimerRateMs);

        }

        #region Trigger update notify

        public void TriggerValueChange() {

            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueObj)));
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueStr)));

            UpdateBoundProperties();

        }

        private void UpdateBoundProperties () {

            //set the bound property values of there is one

            foreach (var prop in boundProperties) {

                //nullable
                var boundPropType = prop.BoundProperty.PropertyType;

                if (boundPropType.IsGenericType && boundPropType.GetGenericTypeDefinition() == typeof(Nullable<>)) {
                    boundPropType = Nullable.GetUnderlyingType(boundPropType);
                }

                bool isBitRegisterAttribute = prop.PropertyAttribute is BitRegisterAttribute;

                if (boundPropType == underlyingSystemType) {

                    //the bound prop is the same type as the one of the underlying register
                    prop.BoundProperty.SetValue(prop.ContainedCollection, ValueObj);
                    prop.ContainedCollection.TriggerPropertyChanged(prop.BoundProperty.Name);

                } else if(boundPropType == typeof(bool) && isBitRegisterAttribute && underlyingSystemType == typeof(Word)) {

                    var bitRegAttr = ((BitRegisterAttribute)prop.PropertyAttribute).bitIndex;

                    if(ValueObj != null) {
                        prop.BoundProperty.SetValue(prop.ContainedCollection, ((Word)ValueObj)[bitRegAttr]);
                    } else {
                        prop.BoundProperty.SetValue(prop.ContainedCollection, null);
                    }

                    prop.ContainedCollection.TriggerPropertyChanged(prop.BoundProperty.Name);


                } else if (boundPropType == typeof(bool) && isBitRegisterAttribute && underlyingSystemType == typeof(DWord)) {

                    var bitRegAttr = ((BitRegisterAttribute)prop.PropertyAttribute).bitIndex;

                    if (ValueObj != null) {
                        prop.BoundProperty.SetValue(prop.ContainedCollection, ((DWord)ValueObj)[bitRegAttr]);
                    } else {
                        prop.BoundProperty.SetValue(prop.ContainedCollection, null);
                    }

                    prop.ContainedCollection.TriggerPropertyChanged(prop.BoundProperty.Name);


                }

            }

        }

        private int updateFreqAvgListIteration = 0;

        protected void TriggerUpdateReceived () {

            if (timeSinceLastUpdate == null) return;

            updateCountTimerCycle++;
            
            if(updateCountTimerCycle >= 1) {

                var updateRateMultiplicator = (float)timeSinceLastUpdate.ElapsedMilliseconds / 1000;
                updateFreqFastCount = ((float)updateCountTimerCycle) / updateRateMultiplicator;

                //populate with first value
                if(updateFreqAvgListIteration == 0) {

                    updateFreqAvgList = Enumerable.Repeat<float>(0, updateFreqAvgList.Length).ToArray();
                    updateFreqAvgListIteration = 1;

                } else if(updateFreqAvgListIteration == updateFreqAvgList.Length - 1) {

                    updateFreqAvgList = Enumerable.Repeat<float>(updateFreqAvgList.Average(), updateFreqAvgList.Length).ToArray();
                    updateFreqAvgListIteration = 1;

                } else {

                    updateFreqAvgList[updateFreqAvgListIteration] = updateFreqFastCount;
                    updateFreqAvgListIteration++;

                }

                //Reset
                updateCountTimerCycle = 0;
                timeSinceLastUpdate.Restart();

            }

        }

        private void UpdateCountTimerTick(int cyclicTimerRateMs) {

            UpdateFreqHz = (float)Math.Round(updateFreqAvgList.Average(), 2);

        }

        #endregion

        public virtual void ClearValue() => UpdateHoldingValue(null);

        internal virtual void UpdateHoldingValue(object val) {

            TriggerUpdateReceived();

            bool nullDiff = false;
            if (val == null && lastValue != null) nullDiff = true;
            if (val != null && lastValue == null) nullDiff = true;

            if (lastValue?.ToString() != val?.ToString() || nullDiff) {

                var beforeVal = lastValue;
                var beforeValStr = GetValueString();

                lastValue = val;

                TriggerValueChange();
                attachedInterface.InvokeRegisterChanged(this, beforeVal, beforeValStr);

            }

        }

        internal virtual object SetValueFromBytes(byte[] bytes) => throw new NotImplementedException();

        internal void WithBoundProperty(RegisterPropTarget propInfo) => boundProperties.Add(propInfo);

        internal void WithBoundProperties(IEnumerable<RegisterPropTarget> propInfos) {

            foreach (var item in propInfos.ToArray())
                boundProperties.Add(item);

        }

        #region Default accessors

        public virtual byte? GetSpecialAddress() => null;

        public virtual string GetValueString() => ValueObj?.ToString() ?? "null";

        public virtual string GetAsPLC() => ValueObj?.ToString() ?? "null";

        public virtual string GetRegisterString() => RegisterType.ToString();

        public virtual string GetMewName() => $"{GetRegisterString()}{MemoryAddress}";

        public virtual uint GetRegisterAddressLen() => throw new NotImplementedException();

        public virtual uint GetRegisterAddressEnd() => MemoryAddress + GetRegisterAddressLen() - 1;

        public string GetRegisterWordRangeString() => $"{GetMewName()} - {MemoryAddress + GetRegisterAddressLen() - 1}";

        #endregion

        protected virtual void CheckAddressOverflow(uint addressStart, uint addressLen) {

            if (addressStart < 0)
                throw new NotSupportedException("The area address can't be negative");

            if (addressStart + addressLen > 99999)
                throw new NotSupportedException($"Memory adresses cant be greater than 99999 (DT{addressStart}-{addressStart + addressLen})");

        }

        protected virtual void AddSuccessRead() {
            if (successfulReads == uint.MaxValue) successfulReads = 0;
            else successfulReads++;
        }

        protected virtual void AddSuccessWrite() {
            if (successfulWrites == uint.MaxValue) successfulWrites = 0;
            else successfulWrites++;
        }

        internal virtual bool IsSameAddressAndType(Register toCompare) {

            return this.MemoryAddress == toCompare.MemoryAddress &&
                   this.RegisterType == toCompare.RegisterType &&
                   this.underlyingSystemType == toCompare.underlyingSystemType &&
                   this.GetRegisterAddressLen() == toCompare.GetRegisterAddressLen() &&
                   this.GetSpecialAddress() == toCompare.GetSpecialAddress();

        }

        internal virtual bool IsSameAddressTypeAndPollLevel(Register toCompare) {

            return IsSameAddressAndType(toCompare) && PollLevel == toCompare.PollLevel;

        }

        internal int AveragePollLevel(List<Register> testAgainst, PollLevelOverwriteMode mode) {

            var whereAddressFitsInto = this.CanFitAddressRange(testAgainst)
                                           .Where(x => !x.wasOverlapFitted).ToList();

            this.wasOverlapFitted = true;
            if (whereAddressFitsInto.Count == 0) return this.pollLevel;

            whereAddressFitsInto.Add(this);

            int avgLvl = mode == PollLevelOverwriteMode.Highest ?
            whereAddressFitsInto.Max(x => x.pollLevel) : whereAddressFitsInto.Min(x => x.pollLevel);

            whereAddressFitsInto.ForEach(x => x.pollLevel = avgLvl);

            return avgLvl;

        }

        internal IEnumerable<Register> CanFitAddressRange(List<Register> testAgainst) {

            foreach (var reg in testAgainst) {

                if (reg == this) continue;

                bool otherFitsInsideSelf = (reg.MemoryAddress >= this.MemoryAddress) &&
                                           (reg.GetRegisterAddressEnd() <= this.GetRegisterAddressEnd()) &&
                                           (reg.GetSpecialAddress() == this.GetSpecialAddress());

                if (otherFitsInsideSelf) yield return reg;

            }

        }

        public override string ToString() {

            var sb = new StringBuilder();
            sb.Append(GetRegisterWordRangeString());
            if (Name != null) sb.Append($" ({Name})");
            sb.Append($" [{this.GetType().Name}({underlyingSystemType.Name})]");
            if (ValueObj != null) sb.Append($" Val: {GetValueString()}");

            return sb.ToString();

        }

        public virtual string ToString(bool additional) {

            if (!additional) return this.ToString();

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"MewName: {GetMewName()}");
            sb.AppendLine($"Name: {Name ?? "Not named"}");
            sb.AppendLine($"Value: {GetValueString()}");
            sb.AppendLine($"Register Type: {RegisterType}");
            sb.AppendLine($"Address: {GetRegisterWordRangeString()}");

            return sb.ToString();

        }

        public virtual string Explain() {

            StringBuilder sb = new StringBuilder();
            sb.Append($"Address: {GetRegisterWordRangeString()}\n");

            if (GetType().IsGenericType)
                sb.Append($"Type: {RegisterType}, {GetType().Name}<{GetType().GenericTypeArguments[0]}>\n");
            else
                sb.AppendLine($"Type: {RegisterType}, {GetType().Name}\n");

            sb.Append($"Name: {Name ?? "Not named"}\n");

            if (ValueObj != null)
                sb.Append($"Value: {GetValueString()}\n");

            sb.Append($"Reads: {successfulReads}, Writes: {successfulWrites}\n");

            if (GetSpecialAddress() != null)
                sb.Append($"SPAddress: {GetSpecialAddress():X1}\n");

            if (boundProperties != null && boundProperties.Count > 0)
                sb.Append($"Bound props: \n\t{string.Join(",\n\t", boundProperties)}");
            else
                sb.Append("No bound properties");

            return sb.ToString();

        }

    }

}
