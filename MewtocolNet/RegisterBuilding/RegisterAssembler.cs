using MewtocolNet.Exceptions;
using MewtocolNet.RegisterAttributes;
using MewtocolNet.Registers;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;

namespace MewtocolNet.RegisterBuilding {

    internal class RegisterAssembler {

        internal RegisterCollection collectionTarget;

        internal MewtocolInterface onInterface;

        internal RegisterAssembler(MewtocolInterface interf) {

            onInterface = interf;

        }

        internal List<Register> AssembleAll(RBuildBase rBuildData, bool flagAutoGenerated = false) {

            List<Register> generatedInstances = new List<Register>();

            foreach (var data in rBuildData.unfinishedList) {

                var generatedInstance = Assemble(data);

                generatedInstance.autoGenerated = flagAutoGenerated;
                data.registerOut?.Invoke(generatedInstance);

                generatedInstances.Add(generatedInstance);

            }

            return generatedInstances;

        }

        internal Register Assemble(StepData data) {

            Register generatedInstance = null;

            if (data.dotnetVarType.IsArray) {

                //-------------------------------------------
                //as array register

                Type elementType = data.dotnetVarType.GetElementType();

                uint numericSizePerElement = (uint)elementType.DetermineTypeByteSize();

                if (elementType.IsEnum && numericSizePerElement > 4) {
                    if (data.boundProperty != null) {
                        throw new NotSupportedException($"Enums not based on 16 or 32 bit numbers are not supported ({data.boundProperty})");
                    } else {
                        throw new NotSupportedException($"Enums not based on 16 or 32 bit numbers are not supported");
                    }
                }

                var sizeStateFlags = DynamicSizeState.None;

                //string with size hint
                if (elementType == typeof(string) && data.perElementByteSizeHint != null) {

                    numericSizePerElement = (uint)data.byteSizeHint + 4;
                    sizeStateFlags = DynamicSizeState.DynamicallySized | DynamicSizeState.WasSizeUpdated;

                } else if (elementType == typeof(string)) {

                    sizeStateFlags = DynamicSizeState.DynamicallySized | DynamicSizeState.NeedsSizeUpdate;

                }

                var parameters = new object[] { 
                    data.memAddress, 
                    data.byteSizeHint,
                    data.arrayIndicies, 
                    sizeStateFlags,
                    data.name 
                };

                var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
                
                Type paramedClass = typeof(ArrayRegister<>).MakeGenericType(data.dotnetVarType);
                ConstructorInfo constr = paramedClass.GetConstructor(flags, null, new Type[] {
                    typeof(uint), 
                    typeof(uint), 
                    typeof(int[]), 
                    typeof(DynamicSizeState), 
                    typeof(string)
                }, null);

                var instance = (Register)constr.Invoke(parameters);

                instance.RegisterType = RegisterType.DT_BYTE_RANGE;

                if (data.boundProperty != null && data.boundProperty.PropertyType != data.dotnetVarType)
                    throw new TypeAccessException($"The bound property {data.boundProperty} must by of type: {data.dotnetVarType}");

                generatedInstance = instance;

            } else if (!data.regType.IsBoolean() && data.dotnetVarType.IsAllowedPlcCastingType()) {

                //-------------------------------------------
                //as single register

                uint numericSize = (uint)data.dotnetVarType.DetermineTypeByteSize();

                if (data.dotnetVarType.IsEnum && numericSize > 4) {
                    if (data.boundProperty != null) {
                        throw new NotSupportedException($"Enums not based on 16 or 32 bit numbers are not supported ({data.boundProperty})");
                    } else {
                        throw new NotSupportedException($"Enums not based on 16 or 32 bit numbers are not supported");
                    }
                }

                var sizeStateFlags = DynamicSizeState.None;

                //string with size hint
                if(data.dotnetVarType == typeof(string) && data.byteSizeHint != null) {

                    numericSize = (uint)data.byteSizeHint + 4;
                    sizeStateFlags = DynamicSizeState.DynamicallySized | DynamicSizeState.WasSizeUpdated;

                } else if (data.dotnetVarType == typeof(string)) {

                    sizeStateFlags = DynamicSizeState.DynamicallySized | DynamicSizeState.NeedsSizeUpdate;

                }
                
                var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

                Type paramedClass = typeof(SingleRegister<>).MakeGenericType(data.dotnetVarType);
                ConstructorInfo constr = paramedClass.GetConstructor(flags, null, new Type[] {
                    typeof(uint), typeof(uint), typeof(DynamicSizeState) ,typeof(string)
                }, null);

                var parameters = new object[] { 
                    data.memAddress, 
                    numericSize, 
                    sizeStateFlags, 
                    data.name 
                };

                var instance = (Register)constr.Invoke(parameters);

                generatedInstance = instance;

            } else if (data.regType.IsBoolean()) {

                //-------------------------------------------
                //as boolean register

                var io = (IOType)(int)data.regType;
                var spAddr = data.specialAddress;
                var areaAddr = data.memAddress;

                var instance = new BoolRegister(io, spAddr, areaAddr, data.name);

                generatedInstance = instance;

            }

            //finalize set for every

            if (generatedInstance == null)
                throw new MewtocolException("Failed to build register");

            if (collectionTarget != null)
                generatedInstance.WithRegisterCollection(collectionTarget);

            if (data.boundProperty != null)
                generatedInstance.WithBoundProperty(new RegisterPropTarget {
                    BoundProperty = data.boundProperty,
                });

            generatedInstance.attachedInterface = onInterface;
            generatedInstance.underlyingSystemType = data.dotnetVarType;
            generatedInstance.pollLevel = data.pollLevel;

            return generatedInstance;

        }

    }

}
